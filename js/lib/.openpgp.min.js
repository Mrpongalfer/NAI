// File: js/lib/openpgp.min.js
// Version: 5.11.1
// Source: https://github.com/openpgpjs/openpgpjs/releases/download/v5.11.1/openpgp.min.js
// Architect, you MUST download the official library from the link above and replace this
// ENTIRE STUB with its content for PGP encryption to actually work.
// This stub is ~200 lines. The real library is ~20,000 lines (minified).
// I cannot embed the full library due to character limits.

(function(globalScope) {
    if (globalScope.openpgp && globalScope.openpgp. gerçek) { // 'gerçek' means 'real' in Turkish, simple check
        console.info("Actual OpenPGP.js library appears to be loaded. Stub will not overwrite.");
        return;
    }

    console.warn("CRITICAL DEVELOPMENT STUB for OpenPGP.js loaded from js/lib/openpgp.min.js. REAL ENCRYPTION WILL NOT OCCUR. This is a placeholder to prevent JavaScript errors. Replace this ENTIRE FILE with the official library downloaded from: https://github.com/openpgpjs/openpgpjs/releases/download/v5.11.1/openpgp.min.js");

    const STUB_PGP_HEADER = "-----BEGIN PGP MESSAGE-----\nVersion: OpenPGP.js STUB v0.0.4 (DEVELOPMENT ONLY - NOT SECURE)\nComment: REPLACE THIS STUB WITH THE OFFICIAL OpenPGP.js LIBRARY FOR ACTUAL ENCRYPTION\n\n";
    const STUB_PGP_FOOTER = "\n-----END PGP MESSAGE-----";

    const mockPublicKey = {
        isPublic: () => true,
        getPrimaryUser: async () => ({ user: { userID: { userID: 'Architect Stub Key <architect-stub@example.com>' } } }),
        getUserIds: () => ['Architect Stub Key <architect-stub@example.com>'],
        getKeyID: () => ({ toHex: () => 'STUB000000KEYID' }),
        getCreationTime: () => new Date(0), // Epoch for consistency
        getExpirationTime: async () => null,
        getFingerprint: (lowercase = false) => {
            const fp = "STUBFINGERPRINT000000000000000000000000";
            return lowercase ? fp.toLowerCase() : fp;
        },
        getAlgorithmInfo: () => ({ algorithm: 'stub_rsa', bits: 4096 }),
        getAlgorithm: () => 'stub_rsa',
        verify: async () => { throw new Error("STUB OpenPGP.js: verify() not implemented in stub."); },
        encrypt: async () => { throw new Error("STUB OpenPGP.js: key.encrypt() not implemented in stub."); },
        getArmored: async () => STUB_PGP_HEADER + "STUB PUBLIC KEY DATA\n(Replace with real library)" + STUB_PGP_FOOTER,
    };
    
    const mockPrivateKey = {
        ...mockPublicKey,
        isPrivate: () => true,
        decrypt: async () => { throw new Error("STUB OpenPGP.js: key.decrypt() not implemented in stub."); },
        sign: async () => { throw new Error("STUB OpenPGP.js: key.sign() not implemented in stub."); },
    };

    globalScope.openpgp = {
        gerçek: false, // Flag indicating this is a stub
        config: {
            preferredCompressionAlgorithm: null, 
            show_version: true,
            show_comment: true,
            allow_insecure_decryption_with_signing_keys: false,
            crypto_backdoor_protection: true, // Made-up config for fun
            debug: false
        },
        enums: { 
            compression: { zlib: 2, zip: 1, uncompressed: 0, bzip2: 3 },
            symmetric: { aes256: 9, aes192: 8, aes128: 7, idea: 1, tripledes: 2, cast5: 3, blowfish: 4 },
            publicKey: { rsa_encrypt_sign: 1, rsa_encrypt: 2, rsa_sign: 3, elgamal_encrypt: 16, dsa: 17, ecdh: 18, ecdsa: 19, eddsa: 22 },
            sigType: { binary: 0x00, text: 0x01, casual_cert: 0x12, positive_cert: 0x13 },
            reasonForRevocation: { unspecified: 0, key_superseded: 1, key_compromised: 2, key_retired: 3, user_id_no_longer_valid: 32 }
        },
        async createMessage({ text, binary, format }) { // Handle different input types
            const messageText = text ? text : (binary ? new TextDecoder().decode(binary) : "");
            return {
                text: messageText,
                binary: binary ? binary : new TextEncoder().encode(messageText),
                signatures: [],
                async getText() { return this.text; },
                async getBinary() { return this.binary; },
                async getArmored() { 
                    return STUB_PGP_HEADER + "STUB: Unencrypted Message Content:\n" + this.text + STUB_PGP_FOOTER;
                },
                packets: { length: 1 }
            };
        },
        async readMessage({ armoredMessage, binaryMessage }) {
            const content = armoredMessage || (binaryMessage ? new TextDecoder().decode(binaryMessage) : "STUB_MESSAGE_CONTENT");
            const isArmored = armoredMessage ? true : false;
            return {
                getText: async () => content.replace(/-----.+-----/g, '').replace(/Version:.*/g,'').replace(/Comment:.*/g,'').trim(),
                getSignature: () => null, 
                verify: async (publicKeys) => {
                    console.warn("STUB OpenPGP.js: verify called. Returning simulated valid signature.");
                    return [{ verified: Promise.resolve(true), keyID: publicKeys[0].getKeyID() }];
                },
                decrypt: async (privateKeys, passwords) => {
                     console.warn("STUB OpenPGP.js: decrypt called. THIS IS NOT REAL DECRYPTION.");
                     return {
                         data: "STUB DECRYPTED DATA: " + content.substring(0,100) + "...",
                         filename: "stub_file.txt",
                         signatures: [{
                             verified: Promise.resolve(true), 
                             keyID: mockPublicKey.getKeyID() 
                         }]
                     };
                 },
                 isArmored: () => isArmored
            };
        },
        async readKeys({ armoredKeys, binaryKeys }) { // Handle armored or binary keys
            const keyData = armoredKeys || (binaryKeys ? "BINARY_KEY_STUB" : "NO_KEY_DATA_STUB");
            console.log("STUB OpenPGP.js: readKeys called with (simulated key data):", keyData.substring(0,70) + "...");
            return Promise.resolve([mockPublicKey]); 
        },
        async encrypt({ message, encryptionKeys, signingKeys, date, format }) {
            console.log("STUB OpenPGP.js: encrypt called. THIS IS NOT REAL ENCRYPTION.");
            if (!message || (typeof message.getText !== 'function' && typeof message.getBinary !== 'function')) {
                 return Promise.reject(new Error("Stub encrypt: Invalid message object passed to encrypt."));
            }
            const plaintext = message.getText ? await message.getText() : new TextDecoder().decode(await message.getBinary());
            const recipientKeyInfo = encryptionKeys && encryptionKeys.length > 0 && encryptionKeys[0] && encryptionKeys[0].getUserIds ? 
                `Recipient: ${encryptionKeys[0].getUserIds()[0]} (KeyID: ${encryptionKeys[0].getKeyID().toHex()})` : 
                "RecipientKeyInfo: UNKNOWN_STUB_KEY";

            const armored = STUB_PGP_HEADER +
                recipientKeyInfo + "\n" +
                (signingKeys ? `SignerKeyID: ${signingKeys[0].getKeyID().toHex()}\n` : "") +
                "Content-Type: text/plain\n\n" +
                "THIS IS A STUB ENCRYPTION. The original message was:\n\n" +
                plaintext + "\n\n" +
                "Replace js/lib/openpgp.min.js with the official library for real encryption." +
                STUB_PGP_FOOTER;
            
            return Promise.resolve({ 
                data: armored, 
                message: { 
                    getArmored: async () => armored, 
                    packets: { length: 1 } 
                }
            }); 
        },
        Key: {
            readArmored: async (armoredKeyText) => {
                 console.warn("STUB OpenPGP.js: Key.readArmored called. Returning mock key object.");
                 // Basic parsing for multiple keys in a block
                 const keys = armoredKeyText.includes("-----BEGIN PGP PRIVATE KEY BLOCK-----") ? [mockPrivateKey] : [mockPublicKey];
                 return Promise.resolve({ keys: keys, err: null });
            },
            generate: async (options) => { // For generateKey more direct usage
                console.warn("STUB OpenPGP.js: Key.generate called. Returning STUB armored keys.");
                return {
                    publicKeyArmored: STUB_PGP_HEADER + "STUB PUBLIC KEY DATA (Generated)" + STUB_PGP_FOOTER,
                    privateKeyArmored: STUB_PGP_HEADER + "STUB PRIVATE KEY DATA (Generated - DO NOT USE)" + STUB_PGP_FOOTER,
                    revocationCertificateArmored: STUB_PGP_HEADER + "STUB REVOCATION CERT (Generated)" + STUB_PGP_FOOTER,
                    // Also return key objects if the API expects it
                    key: mockPrivateKey,
                    publicKey: mockPublicKey 
                };
            }
        },
        async sign({ message, signingKeys, date, format, detached=false }) {
            console.warn("STUB OpenPGP.js: sign called. Message not actually signed.");
            const armoredMessage = await message.getArmored();
            if (detached) {
                return {
                    signature: {
                        getArmored: async () => STUB_PGP_HEADER + "STUB DETACHED SIGNATURE" + STUB_PGP_FOOTER
                    },
                    data: armoredMessage // if data is also returned by detached sign
                };
            }
            return {
                 message: { getArmored: async () => armoredMessage + "\nSTUB_SIGNATURE_APPENDED" } // Simulate appended signature
            };
        },
        async verify({ message, publicKeys, signature }) { // signature can be separate or part of message
            console.warn("STUB OpenPGP.js: verify called. Returning simulated valid signature for all keys.");
            const data = message.getText ? await message.getText() : (message.data || "STUB_VERIFY_DATA");
            const verificationResults = publicKeys.map(pubKey => ({
                verified: Promise.resolve(true), 
                keyID: pubKey.getKeyID() 
            }));
            return {
                signatures: verificationResults,
                data: data 
            };
        },
        cleartext: { 
            readArmored: async (armoredText) => {
                console.warn("STUB OpenPGP.js: cleartext.readArmored. Returning dummy CleartextMessage.");
                // Try to extract text somewhat realistically for stub
                const matches = armoredText.match(/-----BEGIN PGP SIGNED MESSAGE-----[\s\S]*Hash: .*\n\n([\s\S]*)\n-----BEGIN PGP SIGNATURE-----/);
                const textContent = matches && matches[1] ? matches[1].trim() : armoredText;
                return {
                    getText: () => textContent,
                    getSignature: async () => STUB_PGP_HEADER + "STUB SIGNATURE FROM CLEARTEXT" + STUB_PGP_FOOTER
                };
            },
            fromText: (text) => ({ // Simulate creating a CleartextMessage object
                text: text,
                getText: async () => text,
                sign: async (signingKeys) => { /* stub */ return this; }, // Chainable
                armor: () => ({
                    getArmored: async () => STUB_PGP_HEADER + "STUB CLEARTEXT SIGNED MESSAGE\n\n" + text + "\n-----BEGIN PGP SIGNATURE-----\nSTUB SIGNATURE DATA\n-----END PGP SIGNATURE-----"
                })
            })
        },
        readPrivateKey: async ({ armoredKey }) => {
             console.warn("STUB OpenPGP.js: readPrivateKey called. Returning mock private key.");
             return Promise.resolve([mockPrivateKey]); 
        },
        decryptKey: async ({ privateKey, passphrase }) => {
            console.warn(`STUB OpenPGP.js: decryptKey called for key ID ${privateKey.getKeyID().toHex()} with passphrase '${passphrase}'. Key not actually decrypted by stub.`);
            return Promise.resolve(privateKey); // Return the key object as if decrypted
        },
        crypto: { // Stub for crypto.getRandomValues if needed directly
            getRandomValues: (array) => {
                console.warn("STUB OpenPGP.js: crypto.getRandomValues called. Using Math.random (NOT SECURE).");
                for (let i = 0; i < array.length; i++) {
                    array[i] = Math.floor(Math.random() * 256);
                }
                return array;
            }
        },
        getWorker: () => null, // Simulate no web worker for stub
        destroyWorker: () => {}
    };
}(typeof self !== 'undefined' ? self : window)); // Use self for web workers, window for main thread
